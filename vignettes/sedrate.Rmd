---
title: "sedrate"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sedrate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(admtools)
```

## Nonparametric Estimation of age-depth models from sedimentation rates

This vignette gives an example on how to estimate age-depth models from sedimentation rates using the function *sedrate_to_multiadm*. The function takes the following inputs:

-   *h_tp* : a function that returns stratigraphic tie points

-   *t_tp* : a function that returns time tie points

-   *sed_rate_gen*: a function that returns sedimentation rates

-   *h* : vector of heights where the adm is determined

-   *no_of_rep*: integer, number of age-depth models calculated

### Coding Tie Points in Time and Height

Tie points in time and height are coded via the functions *t_tp* (time tie points) and *h_tp* (height tie points) that take no inputs. They serve as wrappers around user-defined procedures that reflect uncertainties of tie points. Every time *t_tp* and *h_tp* are evaluated they return possible values for the tie points.

The function for the stratigraphic tie points must return a named vector with entries "h1" and "h2", corresponding to the lower and higher tie point. "h1" must be smaller than "h2".

For this example, I assume the stratigraphic positions of tie points one and two are known without uncertainty, and are at 10 and 85 m stratigraphic height.

```{r}
h_min = 10 # height of tie point 1
h_max = 85 # height of tie point 2
```

_h_tp_ is then implemented as follows:
```{r}
h_tp = function(){
  return(c("h1" = h_min, 
           "h2" = h_max))
}
```
If it is evaluated, it will simply return the stratigraphic positions of the tie points:
```{r}
#Evaluate stratigraphic positions of tie points
h_tp()
```

The function for time tie points in time must return a named vector with names "t1" (timing of first tie point) and "t2" (timing of second tie point). "t1" must be smaller than "t2".

For this example, I assume the first timing of the first tie point follows a normal distribution with mean 0 and standard deviation 0.1. The timing of the second tie point is bimodal and given as an equal mixture of two normal distributions with means 5 and seven and standard deviations of 0.1c and 0.3. This results in the following implementation for *t_tp*:

```{r}
t_tp = function(){
  # first tie point
  t1 = rnorm(n = 1, mean = 0, sd = 0.1)
  
  # second tie point
  d1 = rbinom(n = 1, size = 2, prob = 0.5) # fair coin flip for mixture
  if (d1 == 0){
    t2 = rnorm(n = 1, mean = 5, sd = 0.1)
  } else {
    t2 = rnorm(n = 1, mean = 7, sd = 0.3)
  }
  return(c("t1" = t1, "t2" = t2))
}
```

Taking Myr as time unit, the distribution of times for the tie points is as follows:

```{r, fig.show="hold", out.width="50%"}
# Evaluate timing of tie points
hist(sapply(1:1000, function(x) t_tp()["t1"]),
     freq = FALSE,
     xlab = "Time [Myr]",
     main = "Timing of first tie point")
hist(sapply(1:1000, function(x) t_tp()["t2"]),
     freq = FALSE,
     xlab = "Time [Myr]",
     main = "Timing of second tie point")

```

### Coding Sedimentation Rates

Sedimentation rates are specified via a function *sed_rate_gen* that takes no inputs. It serves as wrapper for user-defined procedures that specify uncertainties in sedimentation rates. *sed_rate_gen* is a "function factory": every time it is evaluated, it returns another function that is one potential potential sedimentation rate scenario.

I use a simple sedimentation rate model, where only upper and lower bounds on sedimentation rates in the section are known. Between these limits, I assume a uniform distribution.

```{r}
# limits on sed. rates
lower_limit = c(0.1,2,0.1,10)
upper_limit = c(0.2,3,2,12)

# strat intervals where sed rates are defined
s = c(h_min - 1, 30,75, 80, h_max + 1)
```

Based on these parameters, we define the sedimentation rate function factory as follows:
```{r}
# define function factory
sed_rate_fun = function(){
  # draw sed rates from uniform distribution
  aa_1 = c(runif(1,lower_limit[1],upper_limit[1]),
         runif(1, lower_limit[2],upper_limit[2]),
         runif(1,lower_limit[3],upper_limit[3]),
         runif(1, lower_limit[4], upper_limit[4]))
  aa = c(aa_1, aa_1[4])
  # define sed rate "realization" based on samples from uniform distribution
 sed_rate = function(h) approx(x = s,
                                y = aa,
                                xout = h,
                               method = "constant")$y
 # return the function
 return(sed_rate)
}
```

To visualize, here are three sedimentation rates generated by the "sedimentation rate factory" *sed_rate_fun*:

```{r}
plot(NULL,
     xlim = c(10,85),
     ylim = c(0, max(upper_limit)),
     xlab = "Stratigraphic Height [m]",
     ylab = "Sedimentation Rate")
no_of_sedrates = 3
h = seq(h_min,h_max, by = 0.1)
for (i in seq_len(no_of_sedrates)){
  # generate sed rate from the factory
  sed_rate_sample = sed_rate_fun()
  
  # plot sed rate in the section
  lines(h, sed_rate_sample(h))
}
```
All sedimentation rates generated by *sed_rate_fun* will be different, because they are determined by random numbers.

### Estimating the Age-Depth models

The function *sedrate_to_multiadm* estimates the age-depth model from the inputs:

```{R}
my_adm = sedrate_to_multiadm(h_tp = h_tp(),
                      t_tp = t_tp(),
                      sed_rate_gen = sed_rate_fun,
                      h = seq(10,85, by = 1),
                      no_of_rep = 10)
```

It generates a portfolio of age-depth models combined into the variable *madm* (multi-adm)

```{R, echo=FALSE}
plot.multiadm = function(x,...){
  
  #' @export
  #' 
  #' 
  #' 
  
  
  multiadm = x
  no_of_entries = length(multiadm$t)
  t_min = min(sapply(seq_len(no_of_entries), function(x) min(multiadm[["t"]][[x]])))
  t_max = max(sapply(seq_len(no_of_entries), function(x) max(multiadm[["t"]][[x]])))
  h_min = min(sapply(seq_len(no_of_entries), function(x) min(multiadm[["h"]][[x]])))
  h_max = max(sapply(seq_len(no_of_entries), function(x) max(multiadm[["h"]][[x]])))
  
  plot(NULL,
       xlim = c(t_min, t_max),
       ylim = c(h_min, h_max),
       xlab = "Time [Myr]",
       ylab = "Height [m]")
  
  for ( i in seq_len(no_of_entries)){
    graphics::lines(multiadm$t[[i]], multiadm$h[[i]])
  }
  
}

plot(my_adm)

```

These are the 10 age-depth models generated by the *sedrate_to_adm* function, which are all equally likely candidates for the age-depth relationship in the section. Running summary statistics on large number of age-depth models (increasing the *no_of_rep* input variable) gives an assessment of the uncertainties of the age-depth relationship. This can also be used to generate the classic envelopes of uncertainty (95 % CI) used in BChron or other methods.

Highlights:

-   The bimodal timing of the lower tiepoint is clearly visible
-   The shape of the adm is dominated by the initially low sedimentation rates, followed by an interval of intermediate sedimentation rates. The extremely high sedimentation rates at the top of the section have barely any influence although they are one order of magnitude higher.
