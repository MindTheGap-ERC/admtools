---
title: "Estimating Age-Depth Models from Sedimentation Rates"
output: rmarkdown::html_vignette
author: "Niklas Hohmann"
vignette: >
  %\VignetteIndexEntry{Estimating Age-Depth Models from Sedimentation Rates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE}
library(admtools)
```

# Introduction

This vignette explains how to estimate age-depth models (ADMs) from sedimentation rates and tie points using the function `sedrate_to_multiadm`

## Inputs

The `sedrate_to_multiadm` function estimates age-depth models from sedimentation rates and position and timing of tie points. It takes the following inputs that encode user knowledge:

-   `h_tp` : a function encoding stratigraphic positions of tie points

-   `t_tp` : a function encoding times of the tie points

-   `sed_rate_gen`: a function encoding how sedimentation rates change with stratigraphic positions. This information can for example be derived from cyclostratigraphic analyses.

In addition, it takes the following inputs that specify the estimation procedure:

-   `h` : vector of heights where the ADM is determined

-   `no_of_rep`: integer, number of runs

Additional parameters that determine the numeric behavior of the integration method used are `subdivisions` and `stop.on.error`. The parameters `T_unit` and `L_unit` can be used to associate time and length units with the generated age-depth model.

## Example ##

We construct an age depth model for a section of 10 m thickness where upper and lower bounds on sedimentation rates are available.

### Data

We start by defining the section as well as lower and upper bounds on sedimentation rates

```{r}
h_min = 2 # lower boundary of the section
h_max = 10 # upper boundary of the section
T_unit = "Myr"
L_unit = "m"
```

We want to know the age-depth model every 10 cm, so we define

```{r}
h = seq(h_min, h_max, by = 0.1)
```

### Tie points

We assume there is one tie points in the section at 5 m in the section, and its mean age is 66 years with a standard deviation of 0.25 Myr

```{r}
h1 = 5
mean_age = -66
sd = 0.25 
```

Then the tie point timing is given by

```{r}
t_tp = tp_time_norm(mean = mean_age, sd = sd)
```

and the tie point height is given by

```{r}
h_tp = tp_height_det(heights = h1)
```

Every time `t_tp`is evaluated, it returns one possible time of the tie points. Similarily, every time `h_tp`is evaluated, it returns the stratigraphic position of the tie point (which is deterministic in this case):
```{r}
h_tp()
t_tp()
```
### Sedimentation rates

We assume the following upper and lower limits for sedimentation rates:

```{r}
sedrate_max_y = c(2,5,8,5)
sedrate_max_x = c(1,4,6,10)
sedrate_min_y = c(1,1,7,0.5)
sedrate_min_x = sedrate_max_x 
```

Here, `sedrate_max_y[i]` is the upper limit on sedimentation rate at `sedrate_max_x[i]`. Between these points, we assume linear interpolation. This is done by the function `sed_rate_gen_from_bounds`: 

```{r}
sedrate = sed_rate_gen_from_bounds(h_l = sedrate_min_x,
                                   s_l = sedrate_min_y,
                                   h_u = sedrate_max_x,
                                   s_u = sedrate_max_y,
                                   rate = 1)
```

Because the sedimentation rates are uncertain, functions returned by `sedrate` will differ each time the function is evaluated. As an example, we plot three different sample paths (realizations) of the sedimentation rate through the section:

```{r}
plot(NULL,
     xlim = range(h),
     ylim = c(0, max(c(sedrate_max_y))),
     xlab = "Height [m]",
     ylab = "Sedimentation Rate [m/Myr]")
no_sedrates = 3
cols = c("red", "blue", "black")
for (i in seq_len(no_sedrates)){
  sedrate_sample = sedrate()
  lines(h, sedrate_sample(h), lwd = 3, col = cols[i])
}
```
These sedimentation rates assume sedimentation rates are drawn from a uniform distribution between the upper and lower limits of sedimentation rate provided by the user. This is done at random locations determined according to a Poisson point process with rate `rate`.

### Estimate age depth model

With tie points and sedimentation rates specified, we can now estimate the age depth model using

```{r}
my_adm = sedrate_to_multiadm(h_tp = h_tp,
                             t_tp = t_tp,
                             sed_rate_gen = sedrate,
                             h = h,
                             T_unit = T_unit,
                             L_unit = L_unit)
```

The age-depth model can be plotted using

```{r}
plot(my_adm)
```

## Coding user knowledge

### Tie points

Times and heights of tie points are coded via the functions `t_tp` (timing) and `h_tp` (height) that take no inputs. They serve as wrappers around user-defined procedures that reflect uncertainties around tie points. Every time `t_tp` and `h_tp` are evaluated, they return possible values for the tie points. Writing these functions requires some effort, but it allows the user to hand over arbitrarily complex uncertainties of the tie points to the `sedrate_to_multiadm` function. The functions `tp_time_floating_scale`, `tp_time_norm` and `tp_height_det` can be used to simplify the definition of tie points.

The function for the timing of the tie points must return a vector of increasing times.

For this example, I assume that the first tie point follows a normal distribution with mean - 20 Myr before present and standard deviation 0.5 Myr. The timing of the second tie point is bimodal and given as an equal mixture of two normal distributions with means - 5 and - 7 Myr years before present and standard deviations of 0.1 and 0.3 Myr years. This is implemented as follows in `t_tp`:

```{r}
t_tp = function(){
  # first tie point
  t1 = rnorm(n = 1, mean = -20 , sd = 0.5)
  
  # second tie point
  d1 = rbinom(n = 1, size = 2, prob = 0.5) # fair coin flip for mixture
  if (d1 == 0){
    t2 = rnorm(n = 1, mean =  - 5, sd = 0.1)
  } else {
    t2 = rnorm(n = 1, mean =  - 7, sd = 0.3)
  }
  return(c(t1, t2))
}
```

Sampling from `t_tp` yields the following empirical distribution for the tie points:

```{r, fig.show="hold", out.width="50%"}
no_of_samples = 10000
# Evaluate timing of tie points
hist(x = sapply(seq_len(no_of_samples), function(x) t_tp()[1]),
     freq = FALSE,
     xlab = "Time before present [Myr]",
     main = "Timing of first tie point")
hist(x = sapply(seq_len(no_of_samples), function(x) t_tp()[2]),
     freq = FALSE,
     xlab = "Time before present [Myr]",
     main = "Timing of second tie point")

```

The function for the heights of the tie points must return an ordered vector of stratigraphic positions of the tie points. The number of stratigraphic tie points and time tie points must be identical.

For this example, I assume the stratigraphic positions of the tie points is known without uncertainty, and are at 10 and 85 m stratigraphic height.

```{r}
h_min = 10 # height of tie point 1
h_max = 85 # height of tie point 2
```

`h_tp` is then implemented as follows:

```{r}
h_tp = function(){
  return(c(h_min, h_max))
}
```

When evaluated, this function returns the stratigraphic positions of the tie points:

```{r}
#Evaluate stratigraphic positions of tie points
h_tp()
```

This is a lot of effort to simply encode fixed stratigraphic positions of tie points. However, it allows to implement arbitrary uncertainties on the position of the tie points if needed.

### Coding Sedimentation Rates

Sedimentation rates are specified via a function `sed_rate_gen` that takes no inputs. It serves as wrapper for user-defined procedures that specify uncertainties in sedimentation rates. `sed_rate_gen` is a "function factory": every time it is evaluated, it returns another function that is one potential sedimentation rate scenario. Writing this function factory requires some effort, but it allows the user to specify how uncertainties of sedimentation rates are expressed in the section, and implement arbitrarily complex distributions. The idea behind this is that sedimentation rates are considered stochastic processes. Every time `sed_rate_gen` is evaluated, it returns one sample path from this process.

The functions returned by `sed_rate_gen` must return strictly positive values - negative sedimentation rates can not be observed in the section.

I use a simple sedimentation rate model, where only upper and lower bounds on sedimentation rates in the section are known. Between these limits, I assume a uniform distribution.

```{r}
# limits on sed. rates
lower_limit = c(0.1,2,0.1,10)
upper_limit = c(0.2,3,2,12)

# strat intervals where sed rates are defined
s = c(h_min, 30,65, 80, h_max)
```

Based on these parameters, the sedimentation rate function factory is defined as follows:

```{r}
# define function factory
sed_rate_fun = function(){
  # draw sed rates from uniform distribution
  aa = runif(n = length(lower_limit),
             min = lower_limit,
             max = upper_limit)
  # define sed rate "realization" based on samples from uniform distribution
 sed_rate_fun = approxfun(x = s,
                          y = c(aa, aa[length(aa)]), # duplicate right most value bc of step function, see ?stats::approxfun for details
                          method = "constant",
                          rule = 2, #extrapolate outside of domain of definition, see ?stats::approxfun
                          f = 1) # left continuous function
 # return the function
 return(sed_rate_fun)
}
```

To visualize, here are three sedimentation rates generated by the "sedimentation rate function factory" `sed_rate_fun`:

```{r}
plot(NULL,
     xlim = c(h_min, h_max),
     ylim = c(0, max(upper_limit)),
     xlab = "Stratigraphic Height [m]",
     ylab = "Sedimentation Rate")

no_of_sedrates = 3 # no. of sed rates displayed
h = seq(h_min,h_max, by = 0.1) # strat. positions where sed rates are plotted

for (i in seq_len(no_of_sedrates)){
  # generate sed rate from the factory
  sed_rate_sample = sed_rate_fun()
  
  # plot sed rate in the section
  lines(h, sed_rate_sample(h))
}
```

All sedimentation rates generated by `sed_rate_fun` will be different, because they are determined by random numbers.

### Estimating the Age-Depth Models

The function `sedrate_to_multiadm` estimates the age-depth model from the inputs. Here, I determine the age-depth models every meter, and generate 10 ADMs

```{r}
h = seq(h_min,h_max, by = 1) # strat. positions where ADMs are estimated
no_of_rep = 1000 # no. of ADMs estimated
```

```{R}
my_adm = sedrate_to_multiadm(h_tp = h_tp(),
                             t_tp = t_tp(),
                             sed_rate_gen = sed_rate_fun,
                             h = h,
                             no_of_rep = no_of_rep,
                             L_unit = "m",
                             T_unit = "Myr BP")
```

It generates a portfolio of age-depth models combined into the variable `madm` (multi-adm). `madm` is an object of class multiadm.

```{R, echo=FALSE}
plot(my_adm)
L_axis_lab() # plot length axis label, see ?L_axis_lab for details
T_axis_lab() # plot time axis label, see ?T_axis_lab for details
make_legend() # make legend
```

These are 10 age-depth models generated by the `sedrate_to_adm` function, which are all equally likely candidates for the age-depth relationship in the section. Running summary statistics on large number of age-depth models (increasing the `no_of_rep` input variable) gives an assessment of the uncertainties of the age-depth relationship. This can be used to generate the classic envelopes of uncertainty (95 % CI).

## Further information

For information on estimating age-depth models from tracer contents of rocks and sediments, see
```{r, eval=FALSE}
vignette("adm_from_trace_cont")
```
 
For an overview of the structure of the `admtools` package and the classes used therein see

```{r, eval=FALSE}
vignette("admtools_doc")
```